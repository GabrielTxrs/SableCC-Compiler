Package prolixa;

Helpers 
  maiuscula = ['A' .. 'Z'];
  minuscula = ['a' .. 'z'];
  letra = maiuscula | minuscula | 'ç';
  zero = '0';
  nao_zero = ['1' .. '9'];
  digito = ['0' .. '9'];

  tab = 9;
  cr = 13;
  lf = 10;
  all = [0 .. 0xFFFF];
  eol = cr lf | cr | lf;
  not_cr_lf = [all - [cr + lf]];
  not_l_bracket = [all - '{'];
  not_r_bracket = [all - '}'];
  espaco = ' ';
  quotes = ''';
  double_quotes = '"';
  backslash = '\';

  controle = 'a' | 'b' | 't' | 'n' | 'v' | 'f' | '0' | '\' | quotes;
  simbolos = [33 .. 47] | [58 .. 64] | [91 .. 96] | [123 .. 126];

  /* valores booleanos */
  bool_yes = 'yes';
  bool_no  = 'no';


Tokens
  /* frases de cabeçalho */
  this = 'This';
  is = 'is';
  program = 'program';

  it = 'It';
  presents = 'presents';

  let = 'Let';
  us = 'us';
  begin = 'begin';

  that = 'That';
  would = 'would';
  be = 'be';
  all = 'all';

  /* Operadores e símbolos */
  plus      = '+';
  minus     = '-';
  mult      = '*';
  div       = '/';
  mod       = '//';
  assign    = ':=';
  equal     = '=';
  lpar      = '(';
  rpar      = ')';
  lbracket  = '[';
  rbracket  = ']';
  comma     = ',';
  colon     = ':';
  semicolon = ';';
  dot       = '.';
  times     = 'x';

  /* operadores logicos*/
  eq        = '==';
  neq       = '!=';
  le        = '<=';
  ge        = '>=';
  lt        = '<';
  gt        = '>';
  not = '!';

  /* if */
  just = 'just';
  in = 'in';
  case = 'case';
  that_lower = 'that';

  otherwise = 'otherwise';
  do = 'do';

  /* while */
  as = 'as';
  long = 'long';

  /* continue */
  go = 'go';
  next = 'next';
  iteration = 'iteration';

  /* tipos primitivos */
  tipo_symbol = 'symbol';
  tipo_number = 'number';
  tipo_answer = 'answer';

  considering  = 'considering';

  from = 'from';
  by = 'by';
  to = 'to';

  abandon = 'abandon';

  /* operadores logicos */
  and = 'and';
  or  = 'or';
  xor = 'xor';

  /* valores */
  answer = bool_yes | bool_no;
  symbol = quotes (backslash controle | simbolos | letra | digito | espaco) quotes;
  string = double_quotes ([[0 .. 0xffff] - ['"' + '\']] | '\'[0 .. 0xffff])+ double_quotes;
  number = (zero | nao_zero digito*) | (zero | nao_zero digito*) '.' digito+;
  
  identificador = maiuscula ( digito | maiuscula | minuscula |  '_' )*;
  capture = 'capture';
  show = 'show';

  /* modificadores e declaracao de vetor */
  alterable = 'alterable';
  unalterable = 'unalterable';
  vector = 'vector';
  of = 'of';

  comentario_bloco = '{'not_r_bracket*'}';
  vazio = (espaco | cr | lf | tab)+;

Ignored Tokens
  vazio,
  comentario_bloco;


Productions

// ============ PROGRAMA PRINCIPAL ============
start {-> a_prog} = 
  programa                                       {-> programa.a_prog}
;

programa {-> a_prog} =
  this is program identificador dot blocodeclaracoes blocodecomandos {-> New a_prog.prog(identificador, blocodeclaracoes.list_a_decl, blocodecomandos.list_a_cmd)}
;


// ============ DECLARAÇÕES ============
blocodeclaracoes {-> list_a_decl} =
  {com} it presents colon declaracoes            {-> declaracoes.list_a_decl}
| {sem}                                          {-> New list_a_decl.nil()} 
;  

declaracoes {-> list_a_decl} =
  {unica} declaracao                             {-> New list_a_decl.snoc(New list_a_decl.nil(), declaracao.a_decl)}
| {multiplas} declaracoes declaracao             {-> New list_a_decl.snoc(declaracoes.list_a_decl, declaracao.a_decl)}
;

declaracao {-> a_decl} =
  {alterable} alterable tipo identificador semicolon                           {-> New a_decl.alt(tipo.a_type, identificador)}
| {unalterablenoinit} unalterable tipo identificador semicolon                 {-> New a_decl.unaltnoinit(tipo.a_type, identificador)}
| {unalterableinit} unalterable tipo identificador equal valor semicolon       {-> New a_decl.unaltinit(tipo.a_type, identificador, valor.a_val)}
| {vector} vector of tipo lpar dimensao rpar identificador semicolon           {-> New a_decl.vector(tipo.a_type, dimensao.list_a_exp, identificador)}
;

tipo {-> a_type} =
  {number} tipo_number                           {-> New a_type.number()}
| {answer} tipo_answer                           {-> New a_type.answer()}
| {symbol} tipo_symbol                           {-> New a_type.symbol()}
;

dimensao {-> list_a_exp} =
  {unica} exp                                    {-> New list_a_exp.snoc(New list_a_exp.nil(), exp.a_exp)}
| {multiplas} dimensao times exp                 {-> New list_a_exp.snoc(dimensao.list_a_exp, exp.a_exp)}
;


// ============ EXPRESSÕES, VARIÁVEIS E VALORES ============
exp {-> a_exp} = 
  {xor} exp_xor                                  {-> exp_xor.a_exp}
;

exp_xor {-> a_exp} = 
  {single} exp_or                                {-> exp_or.a_exp}
| {xor} [esq]:exp_xor xor [dir]:exp_or           {-> New a_exp.xor(esq.a_exp, dir.a_exp)}
;

exp_or {-> a_exp} = 
  {single} exp_and                               {-> exp_and.a_exp}
| {or} [esq]:exp_or or [dir]:exp_and             {-> New a_exp.or(esq.a_exp, dir.a_exp)}                  
;

exp_and {-> a_exp} =
  {single}  exp_cmp                              {-> exp_cmp.a_exp}
| {and} [esq]:exp_and and [dir]:exp_cmp          {-> New a_exp.and(esq.a_exp, dir.a_exp)}  
;

exp_cmp {-> a_exp} = 
  {single} exp_add                               {-> exp_add.a_exp}
| {eq} [esq]:exp_cmp eq [dir]:exp_add            {-> New a_exp.eq(esq.a_exp, dir.a_exp)}
| {neq} [esq]:exp_cmp neq [dir]:exp_add          {-> New a_exp.neq(esq.a_exp, dir.a_exp)}
| {lt} [esq]:exp_cmp lt [dir]:exp_add            {-> New a_exp.lt(esq.a_exp, dir.a_exp)}
| {gt} [esq]:exp_cmp gt [dir]:exp_add            {-> New a_exp.gt(esq.a_exp, dir.a_exp)}
| {le} [esq]:exp_cmp le [dir]:exp_add            {-> New a_exp.le(esq.a_exp, dir.a_exp)}
| {ge} [esq]:exp_cmp ge [dir]:exp_add            {-> New a_exp.ge(esq.a_exp, dir.a_exp)}
;

exp_add {-> a_exp} = 
  {single} exp_prod                              {-> exp_prod.a_exp}
| {plus} [esq]:exp_add plus [dir]:exp_prod       {-> New a_exp.add(esq.a_exp, dir.a_exp)}
| {minus} [esq]:exp_add minus [dir]:exp_prod     {-> New a_exp.sub(esq.a_exp, dir.a_exp)}
;

exp_prod {-> a_exp} = 
  {single} exp_unary                             {-> exp_unary.a_exp}
| {mult} [esq]:exp_prod mult [dir]:exp_unary     {-> New a_exp.mult(esq.a_exp, dir.a_exp)}
| {div} [esq]:exp_prod div [dir]:exp_unary       {-> New a_exp.div(esq.a_exp, dir.a_exp)}
| {mod} [esq]:exp_prod mod [dir]:exp_unary       {-> New a_exp.mod(esq.a_exp, dir.a_exp)}
;

exp_unary {-> a_exp} = 
  {base} exp_base                                {-> exp_base.a_exp}
| {neg} minus exp_unary                          {-> New a_exp.neg(exp_unary.a_exp)}
| {not} not exp_unary                            {-> New a_exp.not(exp_unary.a_exp)}
;

exp_base {-> a_exp} = 
  {par} lpar exp rpar                            {-> exp.a_exp}
| {valor} valor                                  {-> New a_exp.val(valor.a_val)}
| {var} var                                      {-> New a_exp.var(var.a_var)}
;


var {-> a_var} =
  {simple} identificador                         {-> New a_var.simple(identificador)}
| {indice} identificador lpar list_exp rpar      {-> New a_var.indice(identificador, list_exp.list_a_exp)}
;

valor {-> a_val} =
  {num} number                                   {-> New a_val.num(number)}
| {ans} answer                                   {-> New a_val.ans(answer)}
| {sym} symbol                                   {-> New a_val.sym(symbol)}
| {str} string                                   {-> New a_val.str(string)}
;

unalt {-> identificador} =
  identificador                                  {-> identificador}
;

list_exp {-> list_a_exp} =
  {unica} exp                                    {-> New list_a_exp.snoc(New list_a_exp.nil(), exp.a_exp)}
| {multiplas} list_exp comma exp                 {-> New list_a_exp.snoc(list_exp.list_a_exp, exp.a_exp)}
;

list_var {-> list_a_var} =
  {unica} var                                    {-> New list_a_var.snoc(New list_a_var.nil(), var.a_var)}
| {multiplas} list_var comma var                 {-> New list_a_var.snoc(list_var.list_a_var, var.a_var)}
;


// ============ COMANDOS ============
blocodecomandos {-> list_a_cmd} =
  {com} let us begin colon comandos that would be all dot  {-> comandos.list_a_cmd}
| {sem}                                                    {-> New list_a_cmd.nil()}
;

comandos {-> list_a_cmd} =
  {unico} comando                                          {-> New list_a_cmd.snoc(New list_a_cmd.nil(), comando.a_cmd)}
| {multiplos} comandos comando                             {-> New list_a_cmd.snoc(comandos.list_a_cmd, comando.a_cmd)}
;

comando {-> a_cmd} =
  {m} comando_matched                                      {-> comando_matched.a_cmd}
| {u} comando_unmatched                                    {-> comando_unmatched.a_cmd}
;

comando_matched {-> a_cmd} = 
  {atribuicao} var assign exp semicolon                                                            {-> New a_cmd.assignvar(var.a_var, exp.a_exp)}
| {igual} unalt equal exp semicolon                                                                {-> New a_cmd.assignunalt(unalt.identificador, exp.a_exp)}
| {capture} capture lpar list_var rpar semicolon                                                   {-> New a_cmd.capture(list_var.list_a_var)}
| {show} show lpar list_exp rpar semicolon                                                         {-> New a_cmd.show(list_exp.list_a_exp)}
| {while} [left]:as long [right]:as lpar exp rpar do comando_matched                               {-> New a_cmd.while(exp.a_exp, comando_matched.a_cmd)}
| {for} considering var from [expf]:exp to [expt]:exp by [expb]:exp do comando_matched             {-> New a_cmd.for(var.a_var, expf.a_exp, expt.a_exp, expb.a_exp, comando_matched.a_cmd)}
| {break} abandon semicolon                                                                        {-> New a_cmd.break()}
| {continue} go to next iteration semicolon                                                        {-> New a_cmd.continue()}
| {bloco} bloco                                                                                    {-> New a_cmd.block(bloco.a_block)}
| {ifelse} just in case that_lower lpar exp rpar [doleft]:do [left]:comando_matched otherwise [doright]:do [right]:comando_matched {-> New a_cmd.if(exp.a_exp, left.a_cmd, right.a_cmd)}
;

comando_unmatched {-> a_cmd} =
  {if} just in case that_lower lpar exp rpar do comando                                                                  {-> New a_cmd.ifsimple(exp.a_exp, comando.a_cmd)}
| {ifpartial} just in case that_lower lpar exp rpar [doleft]:do comando_matched otherwise [doright]:do comando_unmatched {-> New a_cmd.if(exp.a_exp, comando_matched.a_cmd, comando_unmatched.a_cmd)}
;


// ============ BLOCO ============
bloco {-> a_block} = 
  {corpo} lbracket declaracoes_bloco comandos_bloco rbracket         {-> New a_block.block(declaracoes_bloco.list_a_decl, comandos_bloco.list_a_cmd)}
;

declaracoes_bloco {-> list_a_decl} =
  {com} declaracoes                                                  {-> declaracoes.list_a_decl}
| {sem}                                                              {-> New list_a_decl.nil()}
;

comandos_bloco{-> list_a_cmd} = 
  {com} comandos                                                     {-> comandos.list_a_cmd}
| {sem}                                                              {-> New list_a_cmd.nil()}
;



Abstract Syntax Tree

a_prog =
  {prog} [name]:identificador [globals]:list_a_decl [cmds]:list_a_cmd
;

a_block = 
  {block} [decls]:list_a_decl [cmds]:list_a_cmd
;

a_type = 
  {number}
| {answer}
| {symbol}
;

maybe_a_val = 
  {none}
| {some} [value]:a_val
;

a_decl = 
  {alt}         [type]:a_type [name]:identificador
| {unaltnoinit} [type]:a_type [name]:identificador
| {unaltinit}   [type]:a_type [name]:identificador [init]:a_val
| {vector}      [type]:a_type [dims]:list_a_exp [name]:identificador
;

a_cmd = 
  {assignvar}    [esq]:a_var [dir]:a_exp
| {assignunalt}  [name]:identificador [dir]:a_exp
| {capture}      [vars]:list_a_var
| {show}         [exps]: list_a_exp
| {while}        [cond]:a_exp [body]:a_cmd
| {for}          [var]:a_var [from]:a_exp [to]:a_exp [by]:a_exp [body]:a_cmd
| {break}
| {continue}
| {block}        [block]:a_block
| {if}           [cond]:a_exp [then]:a_cmd [else]:a_cmd
| {ifsimple}     [cond]:a_exp [then]:a_cmd
;


a_exp = 
  {xor} [esq]:a_exp [dir]:a_exp
| {or}  [esq]:a_exp [dir]:a_exp
| {and} [esq]:a_exp [dir]:a_exp
| {eq}  [esq]:a_exp [dir]:a_exp
| {neq} [esq]:a_exp [dir]:a_exp
| {lt}  [esq]:a_exp [dir]:a_exp
| {gt}  [esq]:a_exp [dir]:a_exp
| {le}  [esq]:a_exp [dir]:a_exp
| {ge}  [esq]:a_exp [dir]:a_exp
| {add} [esq]:a_exp [dir]:a_exp
| {sub} [esq]:a_exp [dir]:a_exp
| {mult} [esq]:a_exp [dir]:a_exp
| {div} [esq]:a_exp [dir]:a_exp
| {mod} [esq]:a_exp [dir]:a_exp
| {neg} [exp]:a_exp
| {not} [exp]:a_exp
| {var} [ref]:a_var
| {val} [lit]:a_val
;

a_var = 
  {simple} [name]:identificador
| {indice} [name]:identificador [args]:list_a_exp
;

a_val = 
  {num} [tok]:number
| {ans} [tok]:answer
| {sym} [tok]:symbol
| {str} [tok]:string
;

list_a_exp = 
  {nil}
| {snoc} [init]:list_a_exp [last]:a_exp
;

list_a_var = 
  {nil}
| {snoc} [init]:list_a_var [last]: a_var
;

list_a_decl = 
  {nil}
| {snoc} [init]:list_a_decl [last]:a_decl
;

list_a_cmd = 
  {nil}
| {snoc} [init]:list_a_cmd [last]:a_cmd
;


